# merged from jumpbox.sh

(git config -l|grep -q alias.lol) || git config --global --add alias.lol "log --graph --decorate --pretty=oneline --abbrev-commit --all"
(git config -l|grep -q alias.co) || git config --global --add alias.co "checkout"
(git config -l|grep -q alias.st) || git config --global --add alias.st "status"
(git config -l|grep -q alias.ci) || git config --global --add alias.ci "duet-commit"

export EDITOR=vi
export TMPDIR=$HOME/tmp
for path_element in $HOME/go/bin $HOME/bin /usr/local/bin ; do
    PATH+=":${path_element}"
done

# Typos
alias bundel='bundle '
alias gti='git '
alias le='less '
alias les='less '

# Useful commands
alias ll='ls -alrt'

function bosh_me() {
  if [[ "$#" -ne 1  || ! "$1" =~ prod|staging|lakitu ]]; then
    echo 'Usage: bosh_me [prod|staging|lakitu]'
    return 1
  fi
  BOSH_ENV=$1

  director_host=bosh.${BOSH_ENV}.cf-app.com
  deployment=$HOME/workspace/deployments-aws/$BOSH_ENV/cf-aws-stub.yml
  if [ $BOSH_ENV = "prod" ]; then
    director_host=bosh.run.pivotal.io
    deployment=${HOME}/workspace/prod-aws/prod/cf-cfapps-io2/cf-cfapps-io2.yml
  elif [ $BOSH_ENV = "staging" ]; then
    deployment=${HOME}/workspace/staging-aws/staging/cf-staging/cf-staging.yml
  elif [ $BOSH_ENV = "lakitu" ]; then
    deployment=${HOME}/workspace/cloudops-ci/lakitu/cf-lakitu-ci/cf-lakitu-ci.yml
  fi

  bosh target $director_host
  bosh deployment $deployment
  bosh status
}

function router_status() {
  if [[ "$#" -ne 1  || ! "$1" =~ prod|staging|lakitu ]]; then
    echo 'Usage: router_status [prod|staging|lakitu]'
    return 1
  fi
  BOSH_ENV=$1
  if [ $BOSH_ENV = "prod" ]; then
    deployment=${HOME}/workspace/prod-aws/prod/cf-cfapps-io2/cf-cfapps-io2.yml
  elif [ $BOSH_ENV = "staging" ]; then
    deployment=${HOME}/workspace/staging-aws/staging/cf-staging/cf-staging.yml
  elif [ $BOSH_ENV = "lakitu" ]; then
    deployment=${HOME}/workspace/cloudops-ci/lakitu/cf-lakitu-ci/cf-lakitu-ci.yml
  fi
  GREP_USER="data = YAML::load(STDIN.read); puts data['properties']['router']['status']['user']"
  GREP_PASS="data = YAML::load(STDIN.read); puts data['properties']['router']['status']['password']"
  user=`cat $deployment | ruby -ryaml -e "$GREP_USER"`
  pass=`cat $deployment | ruby -ryaml -e "$GREP_PASS"`

  for i in varz routes ; do
    bosh vms |grep router | cut -f 5 -d '|' | tr -d ' ' | parallel -j 20 -rt --keep "curl -s http://$user:$pass@{}:8080/$i | jq .> ~/tmp/{}.$i.json" ;
  done
}

##
# Input: 
#   package: The name of the installable package
#   type: The installation source
#   cmd: The command to execute once the package has been confirmed installed.
#
#   Note: the third argument, $cmd, is optional
function which_p() { 
  package="$1"; shift
  type="$1"; shift
  cmd="$@"


  ##
  # One of these will return 0 if the program is installed...
  which "$cmd" 1>/dev/null 2>&1
  errcodea=$?
  type "$cmd" 1>/dev/null 2>&1
  errcodeb=$?
  # Meaning this will multiply to a result of 0
  result=$(( $errcodea * $errcodeb ))

  # Therefore, if result is zero, then it is already installed
  if [[ $result -eq 0 ]] 
  then
    do_nothing=true
  else
    echo "Installing $package"
    case $type in
    "gem")
      gem install "$package"
      ;;
    *)
      echo "Error type: $type not defined"
      exit 2
      ;;
    esac
  fi

  $cmd
}

function repo_all_the_way() {
  ORGREPO="$1"
  REPO="$(basename "${ORGREPO}")"
  git clone "git@github.com:${ORGREPO}"
  pushd "$HOME/workspace/${REPO}"
  if [[ -x update ]]; then
    ./update
  else
    git submodule update --init --recursive
  fi

  # Run bundler
  which_p bundler gem bundle install

  # If no ruby is specified, then we want to run bundler on the other installed rubies
  if [[ -f .ruby-version ]]
  then
    donothing=true
  else
    OLDRUBY=$(chruby | grep \*| awk '{print $2}')
    for i in $(chruby | grep -v \*)
    do
      echo "Running bundler for ruby: $i"
      chruby $i
      which_p bundler gem bundle install
    done
    chruby $OLDRUBY
  fi



  popd
}
export -f repo_all_the_way

export -f chruby
function all_the_repos() {
  ssh -o StrictHostKeyChecking=false -T git@github.com
  mkdir -p ~/workspace
  pushd ~/workspace
  unset GET_ME

  for i in \
           cloudfoundry-incubator/diego-release \
           cloudfoundry/bosh \
           cloudfoundry/bosh-jumpbox \
           cloudfoundry/cf-release \
           cloudfoundry/datadog-config \
           pivotal-cf-experimental/basic-env \
           pivotal-cf/cloudops-ci \
           pivotal-cf/cloudops-tools \
           pivotal-cf/deployments-aws \
           pivotal-cf/prod-aws \
           pivotal-cf/prod-keys \
           pivotal-cf/sprout-wrap \
           pivotal-cf/staging-aws
  do
    [[ -d ${i#*/} ]] || GET_ME+="$i "
  done
  echo $GET_ME
  [[ ! -z $GET_ME ]] && parallel -j 25 -rt --keep repo_all_the_way "{}" ::: $GET_ME

  popd
  unset GET_ME
}

